name: Build Android

on:
  workflow_dispatch:
    inputs:
      app_name:
        description: 'Name of the App'
        required: true
      app_url:
        description: 'URL to convert'
        required: true

jobs:
  build-android:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android

      - name: Rust Cache
        uses: swatinem/rust-cache@v2
        with:
           key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Install Frontend Dependencies
        working-directory: ./app-template
        run: npm install

      - name: Configure App and Inject Intent Handler
        working-directory: ./app-template
        run: |
          # 1. Prepare Variables
          APP_NAME="${{ github.event.inputs.app_name }}"
          APP_URL="${{ github.event.inputs.app_url }}"
          SANITIZED_NAME=$(echo "$APP_NAME" | tr ' ' '' | tr -cd 'a-zA-Z0-9' | tr '[:upper:]' '[:lower:]')
          if [ -z "$SANITIZED_NAME" ]; then SANITIZED_NAME="template"; fi
          IDENTIFIER="com.app.$SANITIZED_NAME"
          # Standard Chrome Mobile UA
          USER_AGENT="Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36"

          echo "Configuring App: Name='$APP_NAME', ID='$IDENTIFIER', URL='$APP_URL'"

          # 2. Modify tauri.conf.json
          # We REMOVE the 'app.windows' array because we will create the window in Rust (lib.rs)
          # This gives us access to 'initialization_script' and robust settings.
          jq --arg name "$APP_NAME" --arg id "$IDENTIFIER" \
             '.productName = $name | .identifier = $id | del(.app.windows)' \
             src-tauri/tauri.conf.json > src-tauri/tauri.conf.json.tmp && mv src-tauri/tauri.conf.json.tmp src-tauri/tauri.conf.json

          # 3. Overwrite src-tauri/src/lib.rs
          # We inject the window creation logic directly here.
          # The initialization script handles 'whatsapp:', 'tel:', 'mailto:', and 'intent:' links.
          # We use `window.open` which the main WebView should handle if possible, 
          # otherwise the plugin_opener (initialized below) allows it.
          
          cat > src-tauri/src/lib.rs <<EOF
          use tauri::{WebviewUrl, WebviewWindowBuilder};

          const INTENT_JS: &str = r#"
            window.addEventListener('click', (e) => {
              const link = e.target.closest('a');
              if (link && link.href) {
                 const href = link.href;
                 if (href.startsWith('whatsapp:') || href.startsWith('mailto:') || href.startsWith('tel:') || href.startsWith('intent:')) {
                    // Force external open
                    window.open(href, '_blank');
                    e.preventDefault();
                 }
              }
            });
          "#;

          #[cfg_attr(mobile, tauri::mobile_entry_point)]
          pub fn run() {
              tauri::Builder::default()
                  .plugin(tauri_plugin_opener::init())
                  .setup(|app| {
                      let url_str = "$APP_URL";
                      let ua = "$USER_AGENT";
                      
                      let url = url_str.parse().expect("Invalid App URL");
                      
                      // Removed .title() as it causes compilation error on mobile
                      let _window = WebviewWindowBuilder::new(app, "main", WebviewUrl::External(url))
                          .user_agent(ua)
                          .initialization_script(INTENT_JS)
                          .build()?;
                      Ok(())
                  })
                  .run(tauri::generate_context!())
                  .expect("error while running tauri application");
          }
          EOF

      - name: Initialize Android Project
        working-directory: ./app-template
        run: npm run tauri android init




      - name: Build Android App
        working-directory: ./app-template
        env:
            NDK_HOME: ${{ env.ANDROID_NDK_HOME }}
        run: npm run tauri android build -- --apk true
      
      - name: Generate Tag Name
        run: echo "TAG_NAME=v-$(echo "${{ github.event.inputs.app_name }}" | tr ' ' '-')-${{ github.run_number }}" >> $GITHUB_ENV
      
      - name: Sign APK
        id: sign_app
        run: |
          # 1. Generate a temporary keystore
          keytool -genkey -v -keystore release.keystore -alias android -keyalg RSA -keysize 2048 -validity 10000 -storepass android -keypass android -dname "CN=Android Release,O=Android,C=US"
          
          # 2. Find the unsigned APK
          UNSIGNED_APK=$(find app-template/src-tauri/gen/android -name "*-unsigned.apk" | head -n 1)
          echo "Found APK: $UNSIGNED_APK"
          
          # 3. Find apksigner tool
          BUILD_TOOLS_VERSION=$(ls $ANDROID_SDK_ROOT/build-tools | sort -r | head -n 1)
          APKSIGNER="$ANDROID_SDK_ROOT/build-tools/$BUILD_TOOLS_VERSION/apksigner"
          echo "Using apksigner: $APKSIGNER"
          
          # 4. Sign the APK (Output proper filename)
          # Use user inputs or sanitized tag for filename
          SANITIZED_NAME=$(echo "${{ github.event.inputs.app_name }}" | tr ' ' '-')
          FINAL_APK="${SANITIZED_NAME}-release.apk"
          
          "$APKSIGNER" sign --ks release.keystore --ks-pass pass:android --key-pass pass:android --out $FINAL_APK "$UNSIGNED_APK"
          
          echo "SIGNED_APK_PATH=$FINAL_APK" >> $GITHUB_ENV

      - name: Create Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
        with:
          tag_name: ${{ env.TAG_NAME }}
          name: "Release ${{ github.event.inputs.app_name }}"
          files: ${{ env.SIGNED_APK_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
